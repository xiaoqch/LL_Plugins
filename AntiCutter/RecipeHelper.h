#pragma once
#include <map>

// VirtualCall
template<typename RTN = void, typename... Args>
RTN inline VirtualCall(void* _this, uintptr_t off, Args... args) {
    return (*(RTN(**)(void*, Args...))(*(uintptr_t*)_this + off))(_this, args...);
}
// This Header is auto generated by BDSLiteLoader Toolchain
struct SortItemInstanceIdAux {
    bool operator() (ItemInstance const& left, ItemInstance const& right) const {
        return SymCall("??RSortItemInstanceIdAux@@QEBA_NAEBVItemInstance@@0@Z",
            bool, SortItemInstanceIdAux*, ItemInstance const&, ItemInstance const&)(nullptr, left, right);
    };
};
class Recipes;
class Recipe;
class ShapelessRecipe;
typedef ItemDescriptorCount RecipeIngredient;
class ItemDescriptor;
class CraftingContainer {
public:
    void* filler[16];
    inline void setItem(int slot, ItemStack const* item) {
        if (!item)
            return;
        SymCall("?setItem@CraftingContainer@@UEAAXHAEBVItemStack@@@Z",
            void, CraftingContainer*, int, ItemStack const*)(this, slot, item);
    };
    inline ItemStack const* getItem(int row, int col) {
        return SymCall("?getItem@CraftingContainer@@QEBAAEBVItemStack@@HH@Z",
            const ItemStack*, CraftingContainer*, int, int)(this, row, col);
    };
    //inline ItemStack const& getItem(int slot) {
    //    return SymCall("?getItem@CraftingContainer@@UEBAAEBVItemStack@@H@Z",
    //        const ItemStack&, CraftingContainer*, int)(this, slot);
    //};

};


class Recipes* getRecipes();
Level* getLevel();

inline unordered_map<string, Recipe*> getRecipesFor(ItemInstance* outputItem) {
    auto htag = HashedString("stonecutter");
    auto& recipesByOutput = dAccess<std::map<ItemInstance, unordered_map<string, Recipe*>, SortItemInstanceIdAux>>(getRecipes(), 56);
    return recipesByOutput[*outputItem];
    //for (auto& [identifier, recipe] : recipes) {

    //    // 此处不验证合成台tag，防止自定义合成台合成误报
    //    //if (dAccess<HashedString>(recipe, 160) != htag)
    //    //    continue;
    //    auto& ingredients = dAccess<vector<RecipeIngredient>>(recipe, 136);

    //    if (ingredients.size() != 1)
    //        continue;

    //    auto& ingredient = ingredients[0];
    //    auto same = SymCall("?sameItemAndAux@ItemDescriptor@@QEBA_NAEBVItemStack@@@Z",
    //        bool, const ItemDescriptor&, const ItemStack*)(ingredient.descriptor, inputItem);
    //    if (same)
    //        return (ShapelessRecipe *)recipe;
    //}
    //return nullptr;
}

inline RecipeIngredient* getIngredientForCutter(ShapelessRecipe* recipe) {
    return SymCall("?getIngredient@ShapelessRecipe@@UEBAAEBVRecipeIngredient@@HH@Z",
        RecipeIngredient*, ShapelessRecipe*, int, int)(recipe, 0, 0);
}

inline size_t getIngredientCount(RecipeIngredient* ingredient) {
    return SymCall("?getStackSize@ItemDescriptorCount@@QEBAFXZ", size_t, RecipeIngredient*)(ingredient);
}

inline ItemDescriptor* getDescriptor(RecipeIngredient* ingredient) {
    return (ItemDescriptor*)ingredient;
}

inline vector<ItemInstance> getRecipeOutput(ShapelessRecipe* recipe) {
    if (!recipe)
        return {};
    return dAccess<vector<ItemInstance>>(recipe, 216);
}

inline bool outputMatch(ShapelessRecipe* recipe, ItemInstance* item) {
    auto recipeOutputs = getRecipeOutput(recipe);
    auto& recipeOutput = recipeOutputs.at(0);
    auto recipeCount = getItemCount((ItemStackBase*)&recipeOutput);
    auto itemCount = getItemCount((ItemStackBase*)item);
    return recipeCount == itemCount;
}

inline bool ingredientMatch(ShapelessRecipe* recipe, ItemStack* item) {
    auto ingredient = getIngredientForCutter(recipe);
    auto expectItem = getDescriptor(ingredient);
    char tmp[80] = {};
    auto inputItem = getDescriptor(item, (ItemDescriptor*)tmp);

    cout << expectItem->getSerializedNameAndAux() << endl;
    cout << inputItem->getSerializedNameAndAux() << endl;

    auto result = SymCall("?sameItemAndAux@ItemDescriptor@@QEBA_NAEBVItemStack@@@Z",
        bool, const ItemDescriptor*, const ItemStack*)(expectItem, item);
    if (!result)
        return result;
    auto expectCount = getIngredientCount(ingredient);
    auto count = getItemCount(item);
    return count >= expectCount;
}

inline bool recipeMatches(Recipe* recipe, CraftingContainer* ctn, Level* lv) {
    return VirtualCall<bool>(recipe, 6*8, ctn, lv);
}